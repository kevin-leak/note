# 储存管理

[TOC]



为什么要进行存储管理？

内存有限，不能将一个大的进程装入内存中。





如何进行存储管理：

- swaping
  - 紧凑：分区
    - 静态：内零头
    - 动态：外零头
    - 伙伴：利用二分，直至找到和进程近似相同的大小的区域，一分为二的区域可以合并
  - 离散：
    - 分段：区域大小可以扩展
    - 分页：内存大小不可以控制
    - 段页：为了模块化设计，我们将程序分成一段一段，并将每一段分成与物理页面相同的页
- 虚拟：只去一部分需要运行的进程文件进去，只需要改进离散即可





## 分区

### 静态

将内存分为大小相同的块，通过交互技术使得进程可以相互交换(**swaping**)

因为进程大小不一，导会出现**内零头**，内存空洞（**hole**)



### 动态

划分为不同大小的内存空间

则会出现一个问题是：如果一个进程被调用出去，我们就会发现剩余的存储空间，并不适合我们新的进程使用

这样就出现了**外零头**



#### 改进

那么当我们出现很多外零头的时候，我们可以使用一些算法进行改进



##### 位图

将内存空间划分，组织成内存空间。

内存的大小和分配单元决定了位图的大小，提供了一种简单的利用一块固定大小的内存区，并实现对内存使用情况的记录，这样我们在调用用进程进入内存的时候我们就必须建立搜索图，实现空闲空间的利用。



##### 链表

将内存信息组织成一个链表：

表结构：

- 空闲区(hole)或者进程(P) 的指示标志
- 起始地址
- 长度
- 下一指针节点



##### 	首次适配

​	沿着链表，找到一个能装的下的内存空间

##### 	下次适配

​	每次都找到能装的下的内存空间，记录当前的位置，以待下一次寻找

##### 	最佳适配

​	找到能容纳，且空闲区最小的内存空间

##### 	最差适配

​	最佳适配会分裂出很多非常小的空闲区，为了合并成最大的空间，我们选择空闲区的最大的内存空间



### 伙伴



## 分页（paging）

因为内存空间是硬件固定的大小（**页框**），并设置了物理地址。



- 为什么要分页？

  内存太小，分页可以解决内存的浪费；如果而后面由于进程太大，我们也加入了虚拟技术。

- 这里先提前说一下，为什么要有虚拟地址？

  因为分页可以实现多级页面，来对页表进行管理，那么此时，我们直接使用物理地址而不建立虚拟地址，就无法实现。



**MMU**：Memory Management Unit 实现 虚拟地址 与 物理地址 的映射



### 页面置换

要实现不同页面的使用，我们就必须对页面进行一个调度。



#### 页表项结构

<img src="..\images\modern\page_table_entity.png" />



- Caching disabled：进制高速缓存
- Referenced：访问位，简写为R
- Modified：是否修改，简写为M
- Protection：保护位，
- Presontabsent：在不在内存
- Page frame number ：页框号



#### 局部性定律

大多数程序总是对少量的页面进行多次访问，而不是相反的，因此只有很少的页表项会被反复读取，这样我们就设计了一个设备 **转换检测缓存区** *（translation lookaside buffer, TLB）



#### 页面置换算法

当发生页面中断的时候，操作系统需要选择一个页面将其换出内存，以便为即将调入的页面腾出空间。

如何换出的页面已经被修改，就必须把他写回磁盘以更新该页面在磁盘上的副本；如果页面没有被修改过，则不需要回写。



##### 最优页面置换算法



##### 最近未使用页面置换算法——NRU

not recently used

根据表项中 ，R和M 的标志选择，R 表示最近是否被访问，R位会每次定期（每次的时钟中断的时候）的清零

##### 先进先出页面置换算法



##### 第二次机会页面置换算法



##### 时钟页面置换算法

就是一个环形链表



##### 最近最少使用页面置换算法



##### 工作集页面置换算法

##### 	改进



#### 置换算法小结

<img src="..\images\modern\page_replacement_algorithm.png " />



### 分页问题







## 分段





## 段页









## 实现问题

















